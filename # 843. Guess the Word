package com.leetcode.problems;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

import com.leetcode.model.Master;

public class Question843 {

	/**
	 * // This is the Master's API interface. // You should not implement it, or
	 * speculate about its implementation interface Master { public int guess(String
	 * word) {} }
	 */
	class Solution1 {
		public void findSecretWord(String[] wordlist, Master master) {
			Random rand = ThreadLocalRandom.current();
			List<String> list = new ArrayList<>();
			for (String s : wordlist)
				list.add(s);
			for (int i = 0; i < 10; i++) {
				String word = list.get(rand.nextInt(list.size()));
				int simi = master.guess(word);
				if (simi == 6)
					return;
				List<String> next = new ArrayList<>();
				for (String s : list) {
					if (getSimi(s, word) == simi)
						next.add(s);
				}
				list = next;
			}
			return;
		}

		private int getSimi(String a, String b) {
			int simi = 0;
			for (int i = 0; i < a.length(); i++) {
				if (a.charAt(i) == b.charAt(i))
					simi++;
			}
			return simi;
		}
	}

	/**
	 * // This is the Master's API interface. // You should not implement it, or
	 * speculate about its implementation interface Master { public int guess(String
	 * word) {} }
	 */
	class Solution2 {
		public void findSecretWord(String[] wordlist, Master master) {
			final int[][] rec = new int[26][6];
			for (final String w : wordlist) {
				for (int i = 0; i < w.length(); i++)
					rec[w.charAt(i) - 'a'][i]++;
			}
			List<String> list = Arrays.asList(wordlist);
			for (int i = 0; i < 10; i++) {
				int weight = 0;
				String candidate = "";
				for (final String s : list) {
					int wgt = getWeight(s, rec);
					if (wgt > weight) {
						weight = wgt;
						candidate = s;
					}
				}
				final int overlap = master.guess(candidate);
				if (overlap == 6)
					return;
				List<String> next = new ArrayList<>();
				for (final String s : list) {
					if (getOverlap(s, candidate) == overlap)
						next.add(s);
				}
				list = next;
			}
		}

		private int getWeight(final String s, final int[][] rec) {
			int ans = 0;
			for (int i = 0; i < s.length(); i++)
				ans += rec[s.charAt(i) - 'a'][i];
			return ans;
		}

		private int getOverlap(final String a, final String b) {
			int ans = 0;
			for (int i = 0; i < a.length(); i++) {
				if (a.charAt(i) == b.charAt(i))
					ans++;
			}
			return ans;
		}
	}

	/**
	 * // This is the Master's API interface. // You should not implement it, or
	 * speculate about its implementation interface Master { public int guess(String
	 * word) {} }
	 */
	class Solution3 {
		public void findSecretWord(String[] wordlist, Master master) {
			int[][] weights = getWeights(wordlist);
			Map<String, Integer> weightRef = getWeightRef(weights, wordlist);
			List<String> list = new ArrayList<>();
			for (String s : wordlist)
				list.add(s);
			for (int i = 0; i < 10; i++) {
				int wei = 0;
				String cand = "";
				for (String s : list) {
					int candWei = weightRef.get(s);
					if (candWei > wei) {
						wei = candWei;
						cand = s;
					}
				}
				int simi = master.guess(cand);
				if (simi == 6)
					return;
				List<String> next = new ArrayList<>();
				for (String s : list) {
					if (getSimi(s, cand) == simi)
						next.add(s);
				}
				list = next;
			}
			return;
		}

		private int[][] getWeights(String[] wordlist) {
			int[][] ans = new int[6][26];
			for (String s : wordlist) {
				for (int i = 0; i < 6; i++)
					ans[i][s.charAt(i) - 'a']++;
			}
			return ans;
		}

		private Map<String, Integer> getWeightRef(int[][] weights, String[] wordlist) {
			Map<String, Integer> map = new HashMap<>();
			for (String s : wordlist) {
				int ans = 0;
				for (int i = 0; i < 6; i++)
					ans += weights[i][s.charAt(i) - 'a'];
				map.put(s, ans);
			}

			return map;
		}

		private int getSimi(String a, String b) {
			int ans = 0;
			for (int i = 0; i < 6; i++) {
				if (a.charAt(i) == b.charAt(i))
					ans++;
			}
			return ans;
		}
	}
}
