class Solution {
    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (List<Integer> edge : connections) {
            graph[edge.get(0)].add(edge.get(1));
            graph[edge.get(1)].add(edge.get(0));
        }
        boolean[] visited = new boolean[n];
        int[] order = new int[n];
        List<List<Integer>> res = new ArrayList<>();
        int[] uuid = new int[1];
        dfs(graph, -1, 0, visited, order, uuid, res);
        return res;
    }
    private void dfs(List<Intaeger>[] graph, int pre, int src, boolean[] visited, int[] order, int[] uuid, List<List<Integer>> res) {
        visited[src] = true;
        order[src] = uuid[0]++;
        int orig_order = order[src];
        for (int i : graph[src]) {
            if (i == pre) {
                continue;
            }
            if (!visited[i]) {
                dfs(graph, src, i, visited, order, uuid, res);
            }
            order[src] = Math.min(order[src], order[i]);
            if (orig_order < order[i]) {
                res.add(Arrays.asList(src, i));
            }
        }
    }
}
