package com.leetcode.problems;

public class Question1540 {
	class Solution {
	    public boolean canConvertString(String s, String t, int k) {
	        if (s.length() != t.length()) {
	            return false;
	        }
	        int[] shiftCounts = new int[26];
	        for (int i = 0; i < s.length(); i++) {
	            if (s.charAt(i) == t.charAt(i)) {
	                continue;
	            }
	            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));
	            int val = shiftCounts[shift] * 26 + shift;
	            if (val > k) {
	                return false;
	            }
	            shiftCounts[shift]++;
	        }
	        return true;
	    }
	    
	    private final int getNumOfShifts(char a, char b) {
	        return (b - a + 26) % 26;
	    }
	}
}


#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
	double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {
		vector<vector<pair<int, double>>> g(n);
		for (int i = 0; i < edges.size(); i++) {
			g[edges[i][0]].push_back({ edges[i][1], succProb[i] });
			g[edges[i][1]].push_back({ edges[i][0], succProb[i] });
		}
		vector<int> seen(n, 0);

		priority_queue<pair<double, int>> pq;
		pq.push({ (double)1.0, start });

		vector<double> mx(n, (double)0.0);
		mx[start] = 1.0;

		while (!pq.empty()) {
			auto t = pq.top();
			pq.pop();
			double prob = t.first;
			int node = t.second;
			if (!seen[node]) {
				seen[node]++;
				for (auto& to : g[node]) {
					if (mx[to.first] < to.second * prob) {
						mx[to.first] = to.second * prob;
						pq.push({ mx[to.first], to.first });
					}
				}
			}
		}
		return mx[end];
	}
};
